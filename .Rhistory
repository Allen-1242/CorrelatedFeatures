Rf_2 <- dcast(melt(setDT(Res), "RowName"),
RowName ~ sub("\\..*", "", variable),
mean,
na.rm = TRUE,
value.var = "value")
Rf_2
dim(pairs_mat)[1] != 0
for(bv in 1:nrow(var_groups))
{
comp <- var_groups[bv]
comp <- unlist(comp[[1]])
temp <- Rf_2[which(Rf_2$RowName %in% comp)]
keep_var <- Rf_2$RowName[Rf_2$Rf == max(temp$Rf)]
rem_var <- comp[which(comp != keep_var)]
#Dropping all values not needed
Rf_2 <- Rf_2[!(Rf_2$RowName %in% unlist(rem_var))]
}
Rf_2
#Fitting the RF without the correlated variables
temp_var <- c(Rf_2$RowName, Y_var)
Data_temp <- Data[,c(..temp_var)]
Rf_list = list()
temp_var
comp
row(var_groups)
nrow(var_groups)
bv <- 1
comp <- var_groups[bv]
comp
comp <- unlist(comp[[1]])
comp
temp <- Rf_2[which(Rf_2$RowName %in% comp)]
temp
Rf_2$RowName[Rf_2$Rf == max(temp$Rf)]
l <- lapply(RF_list, function(x) {x$RowName <- row.names(x) ; x})
Res <- Reduce(function(...) merge(..., by = "RowName", all = TRUE), l)
Rf_2 <- dcast(melt(setDT(Res), "RowName"),
RowName ~ sub("\\..*", "", variable),
mean,
na.rm = TRUE,
value.var = "value")
comp <- var_groups[bv]
comp <- unlist(comp[[1]])
temp <- Rf_2[which(Rf_2$RowName %in% comp)]
temp
rem_var <- comp[which(comp != keep_var)]
rem_var
for(bv in 1:nrow(var_groups))
{
comp <- var_groups[bv]
comp <- unlist(comp[[1]])
temp <- Rf_2[which(Rf_2$RowName %in% comp)]
keep_var <- Rf_2$RowName[Rf_2$Rf == max(temp$Rf)]
rem_var <- comp[which(comp != keep_var)]
#Dropping all values not needed
Rf_2 <- Rf_2[!(Rf_2$RowName %in% unlist(rem_var))]
}
#Fitting the RF without the correlated variables
temp_var <- c(Rf_2$RowName, Y_var)
Data_temp <- Data[,c(..temp_var)]
Rf_list = list()
#Here let us add RFE in order to run it
Rf <- ranger(as.formula(paste(paste(Y_var, '~'), paste(colnames(Data_temp), collapse = "+"))), data = Data_temp, mtry = ncol(Data_temp)/3, importance = 'permutation')
Rf_2 <- data.frame(Rf$variable.importance)
Rf_2
result_rfe2 <- rfe(x = x_train,
y = y_train,
sizes = c(1:17), # 17 features in total
rfeControl = control)
Rf
Rf_2
Rf_2
cumsum(Rf_2$Rf.variable.importance)
Rf_2 <- na.omit(Rf_2)
Rf_2 <- Rf_2[which(Rf_2$Rf >= 0)]
Rf_2 <- na.omit(Rf_2)
Rf_2 <- Rf_2[which(Rf_2$Rf >= 0)]
Rf_2 <- na.omit(Rf_2)
Rf_2 <- Rf_2[which(Rf_2$Rf >= 0)]
Rf_2 <- na.omit(Rf_2)
Rf_2 <- Rf_2[which(Rf_2$Rf >= 0)]
Rf_2 <- na.omit(Rf_2)
Rf_2 <- Rf_2[which(Rf_2$Rf >= 0)]
Rf_2 <- na.omit(Rf_2)
Rf_2 <- Rf_2[which(Rf_2$Rf >= 0)]
Rf
Rf_info_cutoff
Rf_2 <- na.omit(Rf_2)
Rf_2 <- Rf_2[which(Rf_2$Rf.variable.importance >= 0)]
Rf_2 <- na.omit(Rf_2)
Rf_2 <- Rf_2[which(Rf_2$Rf.variable.importance >= 0)]
Rf_2[which(Rf_2$Rf.variable.importance >= 0)]
Rf_2$Rf.variable.importance
which(Rf_2$Rf.variable.importance >= 0
which(Rf_2$Rf.variable.importance >= 0)
which(Rf_2$Rf.variable.importance >= 0)
Rf_2[which(Rf_2$Rf.variable.importance >= 0)]
Rf_2[1]
Rf_2[2]
Rf_2[,which(Rf_2$Rf.variable.importance >= 0)]
Rf_2[,which(Rf_2$Rf.variable.importance >= 0)]
f_2[which(Rf_2$Rf.variable.importance >= 0),]
f_2[which(Rf_2$Rf.variable.importance >= 0),]
f_2[which(Rf_2$Rf.variable.importance >= 0),]
Rf_2[which(Rf_2$Rf.variable.importance >= 0),]
Rf_2 <- Rf_2[which(Rf_2$Rf.variable.importance >= 0),]
Rf_2 <- Rf_2[order(-Rf.variable.importance)]
Rf_2 <- Rf_2[order(-Rf.variable.importance),]
Rf_2 <- Rf_2[order(-Rf_2),]
Rf_2 <- Rf_2[order(-Rf_2),]
Rf_2 <- Rf_2[order(-Rf_2),]
Rf_2 <- Rf_2[order(-Rf_2),]
Rf_2 <- Rf_2[order(-Rf_2),]
Rf_2 <- Rf_2[order(-Rf_2)]
Rf_2 <- Rf_2$Rf.variable.importance/sum(Rf_2$Rf)
Rf.variable.importance
Rf_2 <- Rf_2[order(-Rf_2$Rf.variable.importance)]
Rf_2 <- data.frame(Rf$variable.importance)
Rf_2 <- na.omit(Rf_2)
Rf_2 <- Rf_2[which(Rf_2$Rf.variable.importance >= 0),]
Rf_2 <- Rf_2[order(-Rf_2$Rf.variable.importance)]
Rf_2
Rf_2 <- data.frame(Rf$variable.importance)
Rf_2 <- na.omit(Rf_2)
Rf_2[which(Rf_2$Rf.variable.importance >= 0),]
Rf_2
Rf_2[,1]
Rf_2[,0]
Rf_2[0,]
Rf_2[1,]
Rf_2[1]
names(Rf_2)
rownames(Rf_2)
cbind(rownames(Rf_2), Rf_2[which(Rf_2$Rf.variable.importance >= 0),]
rownames(Rf_2)
rownames(Rf_2)
Rf_2[which(Rf_2$Rf.variable.importance >= 0),
Rf_2[which(Rf_2$Rf.variable.importance >= 0),)]
source("~/GitHub/CorrelatedFeatures/R/Main.R", echo=TRUE)
Rf_2 <- cbind(rownames(Rf_2), Rf_2[which(Rf_2$Rf.variable.importance >= 0),)]
Rf_2 <- cbind(rownames(Rf_2), Rf_2[which(Rf_2$Rf.variable.importance >= 0),)]
Rf_2 <- cbind(rownames(Rf_2), Rf_2[which(Rf_2$Rf.variable.importance >= 0),)]
Rf_2 <- cbind(rownames(Rf_2), Rf_2[which(Rf_2$Rf.variable.importance >= 0),)]
Rf_2 <- cbind(rownames(Rf_2), Rf_2[which(Rf_2$Rf.variable.importance >= 0),)]
CorrelatedFeatures = function(Data, Y_var, Focus_variables = list(), corr_cutoff = 0.7, RF_coverage = 0.95, num_features = 5,  plot = FALSE, fast_calculation = FALSE, cor1 = 'pearson', cor2 = 'PointBiserial', cor3 = 'cramersV')
{
#ToDo
#Perform all subletting and initalizations here
#Creating clusters based upon graph theory
list1 = list()
#Data Cleaning
Data <- DataCleaning(Data)
#note to add all data checks that are needed in the system
#If any NA values drop it
Data[is.na(Data), ] <- 0
#If any value is not a numeric or factor , we drop it
class_check <- as.data.table(sapply(Data, class))
if(any(class_check$V1 %in% 'character'))
{
print('Please convert all chracter variables to factors or dummies')
break
}
Data <- as.data.table(Data)
###Correlation matrix creation
#Examine this further of course
cor_matrix <- GeneralCor(Data[, -Y_var, with = FALSE])
cor_matrix[cor_matrix == 'NULL'] <- 0
ut <- upper.tri(cor_matrix)
pairs_mat <- data.frame(
var1 = rownames(cor_matrix)[row(cor_matrix)[ut]],
var2 = colnames(cor_matrix)[col(cor_matrix)[ut]],
value = unlist((cor_matrix)[ut])
)
#Sub-setting values only above threshold values
pairs_mat = pairs_mat[which(abs(pairs_mat$value) >= corr_cutoff & (pairs_mat$var1 != pairs_mat$var2)),]
rownames(pairs_mat) <- NULL
##Start of Random Forest iterations
list1 = list()
if(dim(pairs_mat)[1] != 0)
{
for(j in 1:nrow(pairs_mat))
{
list1[[j]] = c(pairs_mat[j,1], pairs_mat[j,2])
list1[[j]] = sort(list1[[j]])
}
i = rep(1:length(list1), lengths(list1))
j = factor(unlist(list1))
tab = sparseMatrix(i = i , j = as.integer(j), x = TRUE, dimnames= list(NULL, levels(j)))
connects = tcrossprod(tab, boolArith = TRUE)
group = clusters(graph_from_adjacency_matrix(as(connects, "lsCMatrix")))$membership
var_groups <- tapply(list1, group, function(x) sort(unique(unlist(x))))
var_groups <- as.list(var_groups)
#Condition to extract the focus variables
for(i in 1:length(var_groups))
{
if(any(var_groups[[i]] %in% Focus_variables))
{
if(sum(which(var_groups[[i]] %in% Focus_variables >= 2)))
{
Intersection <- dplyr::intersect(Focus_variables, var_groups[[i]])
var_groups[[i]] <- Intersection[1]
next
}
var_groups[[i]] <- dplyr::intersect(Focus_variables, var_groups[[i]])
}
}
#Getting every combination of variables possible
if(fast_calculation == TRUE)
{
result <- purrr::map(var_groups, 1)
result <- as.data.frame(t(unlist(result)))
}else
{
result <- expand.grid(var_groups)
}
RF_list <- list()
noncor_columns = colnames(Data)[! colnames(Data) %in% unlist(var_groups)]
Data_nocor <- Data[, ..noncor_columns]
##Start of the RF, note we need to add multiprocessing here
for(i in 1:nrow(result))
{
Data_temp <- cbind(Data_nocor, Data[, unlist(result[i,]), with = FALSE])
Rf <- ranger(as.formula(paste(paste(Y_var, '~'), paste(colnames(Data_temp), collapse = "+"))), data = Data_temp, mtry = ncol(Data_temp/3), importance = 'permutation')
Rf_2 <- data.frame(Rf$variable.importance)
RF_list[[i]] <- Rf_2
print(i)
}
}else
{
Rf <- ranger(as.formula(paste(paste(Y_var, '~'), paste(colnames(Data_temp), collapse = "+"))), data = Data_temp, mtry = ncol(Data_temp/3), importance = 'permutation')
Rf_2 <- data.frame(Rf$variable.importance)
RF_list[[i]] <- Rf_2
}
#Fast Aggregation across multiple frames
l <- lapply(RF_list, function(x) {x$RowName <- row.names(x) ; x})
Res <- Reduce(function(...) merge(..., by = "RowName", all = TRUE), l)
Rf_2 <- dcast(melt(setDT(Res), "RowName"),
RowName ~ sub("\\..*", "", variable),
mean,
na.rm = TRUE,
value.var = "value")
#Taking the best variable from each group
if(dim(pairs_mat)[1] != 0)
{
for(bv in 1:nrow(var_groups))
{
comp <- var_groups[bv]
comp <- unlist(comp[[1]])
temp <- Rf_2[which(Rf_2$RowName %in% comp)]
keep_var <- Rf_2$RowName[Rf_2$Rf == max(temp$Rf)]
rem_var <- comp[which(comp != keep_var)]
#Dropping all values not needed
Rf_2 <- Rf_2[!(Rf_2$RowName %in% unlist(rem_var))]
}
#Fitting the RF without the correlated variables
temp_var <- c(Rf_2$RowName, Y_var)
Data_temp <- Data[,c(..temp_var)]
Rf_list = list()
#Here let us add RFE in order to run it
Rf <- ranger(as.formula(paste(paste(Y_var, '~'), paste(colnames(Data_temp), collapse = "+"))), data = Data_temp, mtry = ncol(Data_temp)/3, importance = 'permutation')
Rf_2 <- data.frame(Rf$variable.importance)
##Simple 95%optimization
# #Final RF based on RFE , based on num_features or coverage methods
# if(#Method is based on coverage)
Rf_2 <- na.omit(Rf_2)
Rf_2 <- cbind(rownames(Rf_2, Rf_2[which(Rf_2$Rf.variable.importance >= 0),]
Rf_2 <- Rf_2[order(-Rf_2$Rf.variable.importance)]
library(devtools)
library(pkgdown)
devtools::document()
Rf_2
Rf_2$Rf.variable.importance/sum(Rf_2$Rf.variable.importance)
Rf_2 <- na.omit(Rf_2)
Rf_2 <- Rf_2[which(Rf_2$Rf.variable.importance >= 0,]
Rf_2 <- Rf_2[which(Rf_2$Rf.variable.importance) >= 0,]
Rf_2 <- Rf_2[which(Rf_2$Rf.variable.importance) >= 0,]
Rf_2 <- Rf_2[which(Rf_2$Rf.variable.importance) >= 0,]
Rf_2 <- Rf_2[which(Rf_2$Rf.variable.importance) >= 0,]
Rf_2 <- Rf_2[which(Rf_2$Rf.variable.importance) >= 0,]
Rf_2 <- Rf_2[which(Rf_2$Rf.variable.importance) >= 0,]
Rf_2[which(Rf_2$Rf.variable.importance  >= 0),]
order(-Rf_2$Rf.variable.importance)
Rf_2[which(Rf_2$Rf.variable.importance  >= 0),]
class(Rf_2)
Rf_2 <- data.frame(Rf$variable.importance)
Rf_2
Rf2$Var <- rownames(Rf_2)
Rf_2$Var <- rownames(Rf_2)
Rf_2
Rf_2 <- na.omit(Rf_2)
Rf_2 <- Rf_2[which(Rf_2$Rf.variable.importance  >= 0),]
Rf_2
Rf_2 <- Rf_2[order(-Rf_2$Rf.variable.importance)]
f_2$Rf.variable.importance
Rf_2$Rf.variable.importance
order(-Rf_2$Rf.variable.importance)
Rf_2[order(-Rf_2$Rf.variable.importance)]
Rf_2 <- Rf_2[order(-Rf_2$Rf.variable.importance),]
Rf_2
Rf_2$Rf.variable.importance/sum(Rf_2$Rf.variable.importance)
Rf_2
Rf_2$Rf.variable.importance/sum(Rf_2$Rf.variable.importance)
Rf_2$Rf.variable.importance <- Rf_2$Rf.variable.importance/sum(Rf_2$Rf.variable.importance)
Rf_2$Rf.variable.importance
Rf_2
Rf_2 <- data.frame(Rf$variable.importance)
Rf_2$Var <- rownames(Rf_2)
Rf_2 <- na.omit(Rf_2)
Rf_2 <- Rf_2[which(Rf_2$Rf.variable.importance  >= 0),]
Rf_2 <- Rf_2[order(-Rf_2$Rf.variable.importance),]
<- Rf_2$Rf.variable.importance/sum(Rf_2$Rf.variable.importance)
Rf_2$Rf.variable.importance/sum(Rf_2$Rf.variable.importance)
Rf_2 <- Rf_2$Rf.variable.importance/sum(Rf_2$Rf.variable.importance)
Rf_2 <- cumsum(Rf_2$Rf.variable.importance)
Rf_2$Rf.variable.importance <- Rf_2$Rf.variable.importance/sum(Rf_2$Rf.variable.importance)
Rf_2 <- na.omit(Rf_2)
Rf_2 <- Rf_2[which(Rf_2$Rf.variable.importance  >= 0),]
Rf_2 <- data.frame(Rf$variable.importance)
Rf_2$Var <- rownames(Rf_2)
##Simple 95%optimization
# #Final RF based on RFE , based on num_features or coverage methods
# if(#Method is based on coverage)
Rf_2 <- na.omit(Rf_2)
Rf_2 <- Rf_2[which(Rf_2$Rf.variable.importance  >= 0),]
Rf_2 <- Rf_2[order(-Rf_2$Rf.variable.importance),]
Rf_2$Rf.variable.importance <- Rf_2$Rf.variable.importance/sum(Rf_2$Rf.variable.importance)
cumsum(Rf_2$Rf.variable.importance)
Rf_2 <- cumsum(Rf_2$Rf.variable.importance)
Rf_info_cutoff
Rf_2$Rf.variable.importance > RF_coverage
Rf_2 > RF_coverage
which(Rf_2 > RF_coverage)[1]
temp <- which(Rf_2 > RF_coverage)[1]
temp
Rf_2
Rf_2 <- data.frame(Rf$variable.importance)
Rf_2$Var <- rownames(Rf_2)
##Simple 95%optimization
# #Final RF based on RFE , based on num_features or coverage methods
# if(#Method is based on coverage)
Rf_2 <- na.omit(Rf_2)
Rf_2 <- Rf_2[which(Rf_2$Rf.variable.importance  >= 0),]
Rf_2 <- Rf_2[order(-Rf_2$Rf.variable.importance),]
Rf_2$Rf.variable.importance <- Rf_2$Rf.variable.importance/sum(Rf_2$Rf.variable.importance)
Rf_2
cumsum(Rf_2$Rf.variable.importance)
x1 <- cumsum(Rf_2$Rf.variable.importance)
temp <- which(x1 > RF_coverage)[1]
Rf_2[temp]
Rf_2
Rf_2[,temp]
Rf_2[,1]
Rf_2[0:1]
Rf_2[0:1,]
Rf_2[0:2,]
Rf_2[0:temp,]
Rf_2
x1
Rf_2[0:temp,]
final_variables <- Rf_2[0:temp,]$Var
final_variables
return(final_variables)
CorrelatedFeatures = function(Data, Y_var, Focus_variables = list(), corr_cutoff = 0.7, RF_coverage = 0.95, num_features = 5,  plot = FALSE, fast_calculation = FALSE, cor1 = 'pearson', cor2 = 'PointBiserial', cor3 = 'cramersV')
{
#ToDo
#Perform all subletting and initalizations here
#Creating clusters based upon graph theory
list1 = list()
#Data Cleaning
Data <- DataCleaning(Data)
#note to add all data checks that are needed in the system
#If any NA values drop it
Data[is.na(Data), ] <- 0
#If any value is not a numeric or factor , we drop it
class_check <- as.data.table(sapply(Data, class))
if(any(class_check$V1 %in% 'character'))
{
print('Please convert all chracter variables to factors or dummies')
break
}
Data <- as.data.table(Data)
###Correlation matrix creation
#Examine this further of course
cor_matrix <- GeneralCor(Data[, -Y_var, with = FALSE])
cor_matrix[cor_matrix == 'NULL'] <- 0
ut <- upper.tri(cor_matrix)
pairs_mat <- data.frame(
var1 = rownames(cor_matrix)[row(cor_matrix)[ut]],
var2 = colnames(cor_matrix)[col(cor_matrix)[ut]],
value = unlist((cor_matrix)[ut])
)
#Sub-setting values only above threshold values
pairs_mat = pairs_mat[which(abs(pairs_mat$value) >= corr_cutoff & (pairs_mat$var1 != pairs_mat$var2)),]
rownames(pairs_mat) <- NULL
##Start of Random Forest iterations
list1 = list()
if(dim(pairs_mat)[1] != 0)
{
for(j in 1:nrow(pairs_mat))
{
list1[[j]] = c(pairs_mat[j,1], pairs_mat[j,2])
list1[[j]] = sort(list1[[j]])
}
i = rep(1:length(list1), lengths(list1))
j = factor(unlist(list1))
tab = sparseMatrix(i = i , j = as.integer(j), x = TRUE, dimnames= list(NULL, levels(j)))
connects = tcrossprod(tab, boolArith = TRUE)
group = clusters(graph_from_adjacency_matrix(as(connects, "lsCMatrix")))$membership
var_groups <- tapply(list1, group, function(x) sort(unique(unlist(x))))
var_groups <- as.list(var_groups)
#Condition to extract the focus variables
for(i in 1:length(var_groups))
{
if(any(var_groups[[i]] %in% Focus_variables))
{
if(sum(which(var_groups[[i]] %in% Focus_variables >= 2)))
{
Intersection <- dplyr::intersect(Focus_variables, var_groups[[i]])
var_groups[[i]] <- Intersection[1]
next
}
var_groups[[i]] <- dplyr::intersect(Focus_variables, var_groups[[i]])
}
}
#Getting every combination of variables possible
if(fast_calculation == TRUE)
{
result <- purrr::map(var_groups, 1)
result <- as.data.frame(t(unlist(result)))
}else
{
result <- expand.grid(var_groups)
}
RF_list <- list()
noncor_columns = colnames(Data)[! colnames(Data) %in% unlist(var_groups)]
Data_nocor <- Data[, ..noncor_columns]
##Start of the RF, note we need to add multiprocessing here
for(i in 1:nrow(result))
{
Data_temp <- cbind(Data_nocor, Data[, unlist(result[i,]), with = FALSE])
Rf <- ranger(as.formula(paste(paste(Y_var, '~'), paste(colnames(Data_temp), collapse = "+"))), data = Data_temp, mtry = ncol(Data_temp/3), importance = 'permutation')
Rf_2 <- data.frame(Rf$variable.importance)
RF_list[[i]] <- Rf_2
print(i)
}
}else
{
Rf <- ranger(as.formula(paste(paste(Y_var, '~'), paste(colnames(Data_temp), collapse = "+"))), data = Data_temp, mtry = ncol(Data_temp/3), importance = 'permutation')
Rf_2 <- data.frame(Rf$variable.importance)
RF_list[[i]] <- Rf_2
}
#Fast Aggregation across multiple frames
l <- lapply(RF_list, function(x) {x$RowName <- row.names(x) ; x})
Res <- Reduce(function(...) merge(..., by = "RowName", all = TRUE), l)
Rf_2 <- dcast(melt(setDT(Res), "RowName"),
RowName ~ sub("\\..*", "", variable),
mean,
na.rm = TRUE,
value.var = "value")
#Taking the best variable from each group
if(dim(pairs_mat)[1] != 0)
{
for(bv in 1:nrow(var_groups))
{
comp <- var_groups[bv]
comp <- unlist(comp[[1]])
temp <- Rf_2[which(Rf_2$RowName %in% comp)]
keep_var <- Rf_2$RowName[Rf_2$Rf == max(temp$Rf)]
rem_var <- comp[which(comp != keep_var)]
#Dropping all values not needed
Rf_2 <- Rf_2[!(Rf_2$RowName %in% unlist(rem_var))]
}
#Fitting the RF without the correlated variables
temp_var <- c(Rf_2$RowName, Y_var)
Data_temp <- Data[,c(..temp_var)]
Rf_list = list()
#Here let us add RFE in order to run it
Rf <- ranger(as.formula(paste(paste(Y_var, '~'), paste(colnames(Data_temp), collapse = "+"))), data = Data_temp, mtry = ncol(Data_temp)/3, importance = 'permutation')
Rf_2 <- data.frame(Rf$variable.importance)
Rf_2$Var <- rownames(Rf_2)
##Simple 95%optimization
# #Final RF based on RFE , based on num_features or coverage methods
# if(#Method is based on coverage)
Rf_2 <- na.omit(Rf_2)
Rf_2 <- Rf_2[which(Rf_2$Rf.variable.importance  >= 0),]
Rf_2 <- Rf_2[order(-Rf_2$Rf.variable.importance),]
Rf_2$Rf.variable.importance <- Rf_2$Rf.variable.importance/sum(Rf_2$Rf.variable.importance)
x1 <- cumsum(Rf_2$Rf.variable.importance)
temp <- which(x1 > RF_coverage)[1]
final_variables <- Rf_2[0:temp,]$Var
# if(#method is based on num_columns)
# {
#   Rf_2 <- na.omit(Rf_2)
#   Rf_2 <- Rf_2[which(Rf_2$Rf >= 0)]
#   Rf_2 <- Rf_2[order(-Rf)]
#
#   Rf_2 <- Rf_2$Rf/sum(Rf_2$Rf)
#   Rf_2 <- cumsum(Rf_2$Rf)
#   temp <- which(Rf_2$Rf > Rf_info_cutoff)[1]
# }
}
##Plotting function for correlation methods
if(plot == TRUE)
{
print('lo')
}
return(final_variables)
}
devtools::document()
devtools::test()
usethis::use_readme_md(open = FALSE)
pkgdown::build_site()
